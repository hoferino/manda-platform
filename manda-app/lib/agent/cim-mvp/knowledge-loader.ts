/**
 * Knowledge Loader
 *
 * Loads and queries the JSON knowledge file generated by manda-analyze.
 * Provides caching and search functionality.
 *
 * Story: CIM MVP Fast Track
 */

import { readFile } from 'fs/promises'
import path from 'path'
import type { KnowledgeFile, Finding } from './types'

// In-memory cache for loaded knowledge
let cachedKnowledge: KnowledgeFile | null = null
let cachedPath: string | null = null

/**
 * Load knowledge file from disk
 *
 * @param knowledgePath - Path to knowledge.json file
 * @returns Parsed knowledge file
 */
export async function loadKnowledge(knowledgePath?: string): Promise<KnowledgeFile> {
  // Use provided path or default
  const resolvedPath = knowledgePath || path.join(process.cwd(), 'data', 'test-company', 'knowledge.json')

  // Return cached if same path
  if (cachedKnowledge && cachedPath === resolvedPath) {
    return cachedKnowledge
  }

  try {
    const content = await readFile(resolvedPath, 'utf-8')
    cachedKnowledge = JSON.parse(content) as KnowledgeFile
    cachedPath = resolvedPath

    console.log(`[KnowledgeLoader] Loaded knowledge for ${cachedKnowledge.metadata.company_name}`)
    console.log(`[KnowledgeLoader] Documents: ${cachedKnowledge.metadata.documents.map((d) => d.name).join(', ')}`)
    console.log(`[KnowledgeLoader] Data sufficiency score: ${cachedKnowledge.metadata.data_sufficiency_score}`)

    return cachedKnowledge
  } catch (error) {
    console.error(`[KnowledgeLoader] Failed to load knowledge from ${resolvedPath}:`, error)
    throw new Error(`Failed to load knowledge file: ${error instanceof Error ? error.message : 'Unknown error'}`)
  }
}

/**
 * Get knowledge for a specific CIM section
 *
 * @param section - Section name (e.g., 'executive_summary', 'company_overview')
 * @returns Section data or null if not found
 */
export function getKnowledgeForSection(section: string): unknown {
  if (!cachedKnowledge) {
    throw new Error('Knowledge not loaded. Call loadKnowledge() first.')
  }

  const sections = cachedKnowledge.sections as Record<string, unknown>
  return sections[section] || null
}

/**
 * Search knowledge base for relevant findings
 *
 * @param query - Search query
 * @param section - Optional section to limit search
 * @returns Array of matching findings with sources
 */
export function searchKnowledge(
  query: string,
  section?: string
): Array<{ content: string; source: string; section: string }> {
  if (!cachedKnowledge) {
    return []
  }

  const queryLower = query.toLowerCase()
  const results: Array<{ content: string; source: string; section: string }> = []

  // Search raw extractions
  for (const finding of cachedKnowledge.raw_extractions.all_findings) {
    if (section && finding.extracted_from_section !== section) {
      continue
    }

    if (finding.content.toLowerCase().includes(queryLower)) {
      results.push({
        content: finding.content,
        source: `${finding.source.document}, ${finding.source.location}`,
        section: finding.extracted_from_section,
      })
    }
  }

  return results
}

/**
 * Get all findings for a section
 *
 * @param sectionPath - Dot-notation path (e.g., 'company_overview.history')
 * @returns Array of findings
 */
export function getFindingsForSection(sectionPath: string): Finding[] {
  if (!cachedKnowledge) {
    return []
  }

  const parts = sectionPath.split('.')
  let current: unknown = cachedKnowledge.sections

  for (const part of parts) {
    if (current && typeof current === 'object' && part in current) {
      current = (current as Record<string, unknown>)[part]
    } else {
      return []
    }
  }

  // Check if we have findings array
  if (current && typeof current === 'object' && 'findings' in current) {
    return (current as { findings: Finding[] }).findings
  }

  return []
}

/**
 * Get company metadata
 */
export function getCompanyMetadata(): KnowledgeFile['metadata'] | null {
  return cachedKnowledge?.metadata || null
}

/**
 * Get data gaps from the knowledge file
 */
export function getDataGaps(): KnowledgeFile['data_gaps'] | null {
  return cachedKnowledge?.data_gaps || null
}

/**
 * Clear cached knowledge (useful for testing or reloading)
 */
export function clearKnowledgeCache(): void {
  cachedKnowledge = null
  cachedPath = null
}

/**
 * Format findings as context string for LLM
 *
 * @param section - Section name
 * @returns Formatted string with findings and sources
 */
export function formatSectionContext(section: string): string {
  const findings = getFindingsForSection(section)

  if (findings.length === 0) {
    return `No findings available for section: ${section}`
  }

  const lines = findings.map((f, i) => {
    const source = `[${f.source.document}, ${f.source.location}]`
    return `${i + 1}. ${f.content} ${source}`
  })

  return lines.join('\n')
}

/**
 * Get summary of available data
 */
export function getDataSummary(): string {
  if (!cachedKnowledge) {
    return 'No knowledge loaded'
  }

  const sections = Object.keys(cachedKnowledge.sections)
  const findingCount = cachedKnowledge.raw_extractions.all_findings.length
  const score = cachedKnowledge.metadata.data_sufficiency_score

  // Build a rich summary including key metrics
  const lines: string[] = [
    `**Company:** ${cachedKnowledge.metadata.company_name}`,
    `**Documents analyzed:** ${cachedKnowledge.metadata.documents.length}`,
    `**Total findings:** ${findingCount}`,
    `**Data sufficiency:** ${score}/100`,
    `**Sections available:** ${sections.join(', ')}`,
    '',
    '**Key Findings Preview:**',
  ]

  // Include top findings from each major section (up to 10 total)
  const keyFindings: string[] = []
  const prioritySections = ['financial_performance', 'company_overview', 'market_opportunity', 'competitive_landscape']

  for (const section of prioritySections) {
    const sectionData = cachedKnowledge.sections[section as keyof typeof cachedKnowledge.sections]
    if (sectionData && typeof sectionData === 'object') {
      // Try to get findings from subsections
      for (const [subsection, data] of Object.entries(sectionData)) {
        if (data && typeof data === 'object' && 'findings' in data) {
          const findings = (data as { findings: Finding[] }).findings
          for (const finding of findings.slice(0, 2)) {
            keyFindings.push(`- [${section}/${subsection}] ${finding.content}`)
            if (keyFindings.length >= 10) break
          }
        }
        if (keyFindings.length >= 10) break
      }
    }
    if (keyFindings.length >= 10) break
  }

  if (keyFindings.length > 0) {
    lines.push(...keyFindings)
  } else {
    lines.push('- No detailed findings extracted yet')
  }

  return lines.join('\n')
}
